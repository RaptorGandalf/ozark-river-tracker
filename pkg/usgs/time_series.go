package usgs

import (
	"errors"
	"sort"
	"strconv"
)

const (
	GaugeHeight      = "00065"
	Discharge        = "00060"
	WaterTemperature = "00010"
	Location         = "91110"
)

// Generated by: https://mholt.github.io/json-to-go/
// TODO: Break these anonymous generated structs out into actual objects
type TimeSeriesResponse struct {
	Name         string `json:"name"`
	DeclaredType string `json:"declaredType"`
	Scope        string `json:"scope"`
	Value        struct {
		QueryInfo struct {
			QueryURL string `json:"queryURL"`
			Criteria struct {
				LocationParam string        `json:"locationParam"`
				VariableParam string        `json:"variableParam"`
				Parameter     []interface{} `json:"parameter"`
			} `json:"criteria"`
			Note []struct {
				Value string `json:"value"`
				Title string `json:"title"`
			} `json:"note"`
		} `json:"queryInfo"`
		TimeSeries []TimeSeries `json:"timeSeries"`
	} `json:"value"`
	Nil             bool `json:"nil"`
	GlobalScope     bool `json:"globalScope"`
	TypeSubstituted bool `json:"typeSubstituted"`
}

type TimeSeries struct {
	SourceInfo struct {
		SiteName string `json:"siteName"`
		SiteCode []struct {
			Value      string `json:"value"`
			Network    string `json:"network"`
			AgencyCode string `json:"agencyCode"`
		} `json:"siteCode"`
		TimeZoneInfo struct {
			DefaultTimeZone struct {
				ZoneOffset       string `json:"zoneOffset"`
				ZoneAbbreviation string `json:"zoneAbbreviation"`
			} `json:"defaultTimeZone"`
			DaylightSavingsTimeZone struct {
				ZoneOffset       string `json:"zoneOffset"`
				ZoneAbbreviation string `json:"zoneAbbreviation"`
			} `json:"daylightSavingsTimeZone"`
			SiteUsesDaylightSavingsTime bool `json:"siteUsesDaylightSavingsTime"`
		} `json:"timeZoneInfo"`
		GeoLocation struct {
			GeogLocation struct {
				Srs       string  `json:"srs"`
				Latitude  float64 `json:"latitude"`
				Longitude float64 `json:"longitude"`
			} `json:"geogLocation"`
			LocalSiteXY []interface{} `json:"localSiteXY"`
		} `json:"geoLocation"`
		Note         []interface{} `json:"note"`
		SiteType     []interface{} `json:"siteType"`
		SiteProperty []struct {
			Value string `json:"value"`
			Name  string `json:"name"`
		} `json:"siteProperty"`
	} `json:"sourceInfo"`
	Variable struct {
		VariableCode        []VariableCode `json:"variableCode"`
		VariableName        string         `json:"variableName"`
		VariableDescription string         `json:"variableDescription"`
		ValueType           string         `json:"valueType"`
		Unit                struct {
			UnitCode string `json:"unitCode"`
		} `json:"unit"`
		Options struct {
			Option []struct {
				Name       string `json:"name"`
				OptionCode string `json:"optionCode"`
			} `json:"option"`
		} `json:"options"`
		Note             []interface{} `json:"note"`
		NoDataValue      float64       `json:"noDataValue"`
		VariableProperty []interface{} `json:"variableProperty"`
		Oid              string        `json:"oid"`
	} `json:"variable"`
	Values []Value `json:"values"`
	Name   string  `json:"name"`
}

type Value struct {
	Value     []TimeSeriesValue `json:"value"`
	Qualifier []struct {
		QualifierCode        string `json:"qualifierCode"`
		QualifierDescription string `json:"qualifierDescription"`
		QualifierID          int    `json:"qualifierID"`
		Network              string `json:"network"`
		Vocabulary           string `json:"vocabulary"`
	} `json:"qualifier"`
	QualityControlLevel []interface{} `json:"qualityControlLevel"`
	Method              []struct {
		MethodDescription string `json:"methodDescription"`
		MethodID          int    `json:"methodID"`
	} `json:"method"`
	Source     []interface{} `json:"source"`
	Offset     []interface{} `json:"offset"`
	Sample     []interface{} `json:"sample"`
	CensorCode []interface{} `json:"censorCode"`
}

type TimeSeriesValue struct {
	Value      string   `json:"value"`
	Qualifiers []string `json:"qualifiers"`
	DateTime   string   `json:"dateTime"`
}

type VariableCode struct {
	Value      string `json:"value"`
	Network    string `json:"network"`
	Vocabulary string `json:"vocabulary"`
	VariableID int    `json:"variableID"`
	Default    bool   `json:"default"`
}

func (t *TimeSeriesResponse) GetMostRecentGaugeHeight() (float64, error) {
	values, err := getValues(t, GaugeHeight)
	if err != nil {
		return -1, err
	}

	values = sortValuesByDate(values)

	return strconv.ParseFloat(values[0].Value, 64)
}

func (t *TimeSeriesResponse) GetMostRecentDischarge() (float64, error) {
	values, err := getValues(t, Discharge)
	if err != nil {
		return -1, err
	}

	values = sortValuesByDate(values)

	return strconv.ParseFloat(values[0].Value, 64)
}

func (t *TimeSeriesResponse) GetMostRecentWaterTemperature() (float64, error) {
	values, err := getValues(t, WaterTemperature)
	if err != nil {
		return -1, err
	}

	values = sortValuesByDate(values)

	return strconv.ParseFloat(values[0].Value, 64)
}

func getValues(response *TimeSeriesResponse, metric string) ([]TimeSeriesValue, error) {
	var timeSeries TimeSeries

	for _, t := range response.Value.TimeSeries {
		if t.Variable.VariableCode[0].Value == metric {
			timeSeries = t
			break
		}
	}

	if len(timeSeries.Values) == 0 {
		return []TimeSeriesValue{}, errors.New("No values found for specified metric.")
	}

	return timeSeries.Values[0].Value, nil
}

func sortValuesByDate(values []TimeSeriesValue) []TimeSeriesValue {
	sort.SliceStable(values, func(i, j int) bool {
		return values[i].DateTime > values[j].DateTime
	})

	return values
}
